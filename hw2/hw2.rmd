---
title: "Biostat M280 Homework 2"
subtitle: Due Feb 16 @ 11:59PM
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Q1

Read [Chapter 7](http://r4ds.had.co.nz/exploratory-data-analysis.html) (Exploratory Data Analysis) of _R for Data Science_ and do exercises 7.3.4, 7.4.1, 7.5.1.1, 7.5.2.1, and 7.5.3.1.

#### exercises 7.3.4
1.Explore the distribution of each of the x, y, and z variables in diamonds. What do you learn? Think about a diamond and how you might decide which dimension is the length, width, and depth.
```{r}
library("tidyverse")
diamonds <- diamonds %>% filter(2 < y & y < 20 & 2 < x & 2 < z & z < 20)
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = x)) + ggtitle("Histogram of x")
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = y)) + ggtitle("Histogram of y")
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = z)) + ggtitle("Histogram of z")
```
* Answer: By the histogram, the distribution of x,y,z are all right skewed, which means smaller diamonds are more than larger diamonds. In addition, the distribution of x and y are very similar. 

2. Explore the distribution of price. Do you discover anything unusual or surprising? (Hint: Carefully think about the binwidth and make sure you try a wide range of values.)

```{r}
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = price), binwidth = 40)

ggplot(filter(diamonds, price < 1600 & price > 1400), aes(x = price)) +
  geom_histogram(binwidth = 1, center = 0)
```
* Answer: The overall distribution of price showed right skewed. Unsual and suprising part is that there is no diamond between 1460 and 1590. 

3. How many diamonds are 0.99 carat? How many are 1 carat? What do you think is the cause of the difference?
```{r}
filter(diamonds, carat == 0.99) %>%
  summarise(n())
```
```{r}
filter(diamonds, carat == 1) %>%
  summarise(n())
```
* Answer: there are only 23 diamonds are 0.99 carat but 1558 diamonds are 1 carat. I think the reason is that the most measurements for diamonds can not be preicise to 0.01.

4. Compare and contrast coord_cartesian() vs xlim() or ylim() when zooming in on a histogram. What happens if you leave binwidth unset? What happens if you try and zoom so only half a bar shows?
```{r}
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y),binwidth = 0.5) +
  coord_cartesian(ylim = c(0, 100))
# What happens if you leave binwidth unset?
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y)) +
  coord_cartesian(ylim = c(0, 100))
# What happens if you try and zoom so only half a bar shows?

```

#### exercises 7.4.1
1. What happens to missing values in a histogram? What happens to missing values in a bar chart? Why is there a difference?
```{r}
diamonds %>%
  ggplot(aes(price)) +
  geom_histogram(bins = 500)

diamonds %>%
  ggplot(aes(price)) +
  geom_bar()
```
* Answer: 

2. What does na.rm = TRUE do in mean() and sum()?
```{r}
mean(c(10, 30, 20, NA), na.rm = FALSE)
mean(c(10, 30, 20, NA), na.rm = TRUE)
sum(c(10, 30, 20, NA), na.rm = FALSE)
sum(c(10, 30, 20, NA), na.rm = TRUE)
```
* Answer: na.rm is used to remove NA (missing value) to calculate the mean and sum. If the data has missing value and na.rm = FALSE, then there will be no result.

#### 7.5.1.1
1. Use what you’ve learned to improve the visualisation of the departure times of cancelled vs. non-cancelled flights.
```{r}
library("nycflights13")
nycflights13::flights %>% mutate(cancelled = is.na(dep_time)) %>%
    ggplot(aes(sched_dep_time)) +
    geom_density() +
    facet_wrap(~cancelled) 
```
*  Answer: By the density for depature time we can see the distribution clearly, most of the cancelled flights were shechdule at afternoon.

2. What variable in the diamonds dataset is most important for predicting the price of a diamond? How is that variable correlated with cut? Why does the combination of those two relationships lead to lower quality diamonds being more expensive?
* I think the most important for predicting the price of a diamond is carat(how big is it).
The plot of carat and price shown as below:
```{r}
ggplot(data = diamonds, mapping = aes(x = price)) + 
  geom_point(mapping = aes(x = carat, y = price,colour = cut))

ggplot(diamonds) +
  geom_boxplot(aes(x = cut, y = carat))

```
* Answer: Because better cut has lower carat which makes their price lower, so if we don’t look at carat, it would appear that better cut has lower price.

3. Install the ggstance package, and create a horizontal boxplot. How does this compare to using coord_flip()?
```{r}
library(ggstance)
ggplot(diamonds) + geom_boxploth(aes(x = carat, y = cut))
ggplot(diamonds) + geom_boxplot(aes(x = cut, y = carat)) + coord_flip()

```
* The result plots showed they are same.

4. One problem with boxplots is that they were developed in an era of much smaller datasets and tend to display a prohibitively large number of “outlying values”. One approach to remedy this problem is the letter value plot. Install the lvplot package, and try using geom_lv() to display the distribution of price vs cut. What do you learn? How do you interpret the plots?
```{r}
library(lvplot)
ggplot(diamonds, aes(x = cut, y = price)) + geom_lv() 
```
* Answer: 

5. Compare and contrast geom_violin() with a facetted geom_histogram(), or a coloured geom_freqpoly(). What are the pros and cons of each method?
```{r}
# use geom_violin()
ggplot(diamonds) +
  geom_violin(aes(x = cut, y = price))
# use geom_histogram()
ggplot(diamonds) +
  geom_histogram(aes(x = price), binwidth = 20) +
  facet_wrap(~cut)
# use geom_freqpoly()
ggplot(diamonds) +
  geom_freqpoly(aes(x = price)) +
  facet_wrap(~cut)
```
* Answer: geom_violin() showed smoth curve but difficult to see where is peak. geom_histogram() can be modified with but hart to make compairision. geom_freqpoly() can showed the trends very well but cannot showed the gaps and exact count.

6.If you have a small dataset, it’s sometimes useful to use geom_jitter() to see the relationship between a continuous and categorical variable. The ggbeeswarm package provides a number of methods similar to geom_jitter(). List them and briefly describe what each one does.
```{r}
library(ggbeeswarm)
ggplot(diamonds, aes(cut, carat)) +
    geom_quasirandom()
ggplot(diamonds, aes(cut, carat)) +
    geom_jitter()
```

####7.5.2.1

1.How could you rescale the count dataset above to more clearly show the distribution of cut within colour, or colour within cut?
```{r}
# install.packages("viridisLite")
# library(viridisLite)
# diamonds %>% 
#   count(color, cut) %>% 
#   group_by(color) %>%
#   ggplot(mapping = aes(x = color, y = cut)) +
#   geom_tile(mapping = aes(fill = n)) +
#   scale_color_viridis()
# 
# diamonds %>% 
#   count(color, cut) %>% 
#   group_by(color) %>% 
#   mutate(prop = n / sum(n)) %>% 
#   ggplot(aes(x = color, y = cut)) +
#   geom_tile(aes(fill = prop))
```

2. Use geom_tile() together with dplyr to explore how average flight delays vary by destination and month of year. What makes the plot difficult to read? How could you improve it?
```{r}

```

3.Why is it slightly better to use aes(x = color, y = cut) rather than aes(x = cut, y = color) in the example above?
```{r}

```

####7.5.3.1
1. Instead of summarising the conditional distribution with a boxplot, you could use a frequency polygon. What do you need to consider when using cut_width() vs cut_number()? How does that impact a visualisation of the 2d distribution of carat and price?
* Answer: cut_width() makes groups of width width; cut_number() makes n groups with (approximately) equal numbers of observations.
```{r}
ggplot(data = diamonds, aes(x=carat, colour = cut_number(price, 10))) +
 geom_freqpoly(bins = 100)
ggplot(data = diamonds, aes(x=carat, colour = cut_width(price, 2000))) +
 geom_freqpoly(bins = 100)

ggplot(data = diamonds, 
       mapping = aes(x = price, colour = cut_width(carat, 0.3))) +
  geom_freqpoly(bins = 100)
```

2. Visualise the distribution of carat, partitioned by price.
* Use the cut_width() to make the plot partitioned by price.
```{r}
ggplot(diamonds) +
  geom_density(mapping = aes(x = carat,
                             color = cut_width(price, 5000, boundary = 0)))
```

3. How does the price distribution of very large diamonds compare to small diamonds. Is it as you expect, or does it surprise you?
```{r}
ggplot(diamonds) +
geom_boxplot(mapping = aes(x = cut_width(carat, 1),
                             y = price))
ggplot(diamonds) +
geom_boxplot(mapping = aes(x = cut_number(carat, 12),
                             y = price))

```
* Answer: Use cut_width and cut_number to do the boxplot. As I expect, as the carat get large the price also get large. In addition, I found Large diamonds' prices are super high.

4. Combine two of the techniques you’ve learned to visualise the combined distribution of cut, carat, and price.
```{r}
# Use geom_jitter()
ggplot(diamonds) +
  geom_jitter(mapping = aes(x = cut, y = price,
                             color = cut_number(carat, 5)))
```
```{r}
#Or use geom_boxplot()
ggplot(diamonds) +
  geom_boxplot(mapping = aes(x = cut, y = price,
                             color = cut_number(carat, 5)))
```

5. Two dimensional plots reveal outliers that are not visible in one dimensional plots. For example, some points in the plot below have an unusual combination of x and y values, which makes the points outliers even though their x and y values appear normal when examined separately.
```{r}
ggplot(data = diamonds) +
  geom_point(mapping = aes(x = x, y = y)) +
  coord_cartesian(xlim = c(4, 11), ylim = c(4, 11))
```
Why is a scatterplot a better display than a binned plot for this case?
* If we use the binned plot, the result showed as below:
```{r}
ggplot(data = diamonds) +
  geom_bin2d(mapping = aes(x = x, y = y), bins = 100)
```
* The shape of the line showed similar pattern. But I believe that scatterplot a better display than a binned plot is because that count in this case is not very important, so it is better to focus on the patter of the x and y.

## Q2 (optional)

Read [Chapter 23](http://r4ds.had.co.nz/model-basics.html) (Model Basics) and [Chapter 24](http://r4ds.had.co.nz/model-building.html) (Model Building) of _R for Data Science_ and do exercises 24.2.3 and 24.3.5.

## Q3

Redo HW1 Q2 using tidyverse.
* Read in data
```{r}
library("tidyverse")
geno_data1 <- read_tsv("/home/m280-data/hw1/merge-geno.bim", col_names = F) 
geno_data1 <- as_data_frame(geno_data1)
colnames(geno_data1) <- c("Chromosome","SNP_ID","Genetic_Distance","bp",
                       "Allele 1","Allele 2")
geno_data2 <- read_delim("/home/m280-data/hw1/merge-geno.fam"," ", col_names = F)
geno_data2 <- as_data_frame(geno_data2)
colnames(geno_data2) <- c("Family","Person","Father","Mother",
                       "Sex","Affection")
```
1. How many persons are in the data set (statisticians call this n)? How many SNPs are in the data set (statisticians call this p)?

```{r}
geno_data1 %>% 
  count()
geno_data2 %>% 
  count()
```
* Answer: n = $959$ ; p = $8348674$. 

2. Which chromosomes does this data set contain? How many SNPs are in each chromosome?

```{r}
geno_data1 %>% 
  group_by(Chromosome) %>% 
  summarise(n = n()) 
```
* Answer:

| $Chromesome$ | $SNPs$ |
|--------------|--------|
|     1        |1309299 |
|     3        |1215399 |
|     5        |1090185 |
|     7        | 980944 |
|     9        | 732013 |
|     11       | 815860 |
|     13       | 602809 |
|     15       | 491208 |
|     17       | 477990 |
|     19       | 393615 |
|     21       | 239352 |


3. MAP4 (microtubule-associated protein 4) is a gene on chromosome 3 spanning positions 47,892,180 bp – 48,130,769 bp. How many SNPs are located within MAP4 gene?
```{r}
filter(geno_data1, Chromosome == 3, bp >= 47892180, bp <= 48130769 ) %>% 
  summarise(n = n()) 
```
* Answer: There are 894 SNPs located within MAP4 gene.

4. Reformat:
* Part 1:
```{r}
output_file <- "/home/huiyuhu/biostat-m280-2018-winter/hw2/mendel1.txt"
fileConn <- file(output_file, open = "a")
writeLines("    2.40 = FILE FORMAT VERSION NUMBER", fileConn)
writeLines("8348674 = NUMBER OF SNPS LISTED HERE", fileConn)
close(fileConn)

mendel <- geno_data1[, c("SNP_ID", "Chromosome","bp")]
write_delim(mendel, output_file, delim = ",", col_names = FALSE, append = TRUE)
```
```{bash}
head /home/huiyuhu/biostat-m280-2018-winter/hw2/mendel1.txt
```

* Part 2:
```{r}
output_file <- "/home/huiyuhu/biostat-m280-2018-winter/hw2/mendel2.txt"

mendel2 <- geno_data2 %>%
  mutate(Sex = replace(Sex, Sex == 1, "M")) %>%
  mutate(Sex = replace(Sex, Sex == 2, "F")) %>%
  mutate(Father = replace(Father, Father == "0", "")) %>%
  mutate(Mother = replace(Mother, Mother == "0", "")) %>%
  mutate(Affection = replace(Affection, Affection == 0, "")) %>%
  mutate(Person = str_replace(Person, "T2DG", "")) %>%
  mutate(Father = str_replace(Father, "T2DG", "")) %>%
  mutate(Mother = str_replace(Mother, "T2DG", "")) 
 
write_delim(mendel2, output_file, delim = ",", col_names = FALSE)
```

```{bash}
head -20 /home/huiyuhu/biostat-m280-2018-winter/hw2/mendel2.txt
```

## Q4 (optional)

Redo HW1 Q3 on Hoffman2, except now we want to submit each `runSum.R` job to a different node in the cluster.
